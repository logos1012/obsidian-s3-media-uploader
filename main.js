/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => S3UploaderPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// src/api/S3Uploader.ts
var S3Uploader = class {
  constructor(apiEndpoint) {
    this.apiEndpoint = apiEndpoint;
  }
  /**
   * Request a presigned URL from the API
   */
  async requestPresignedUrl(file) {
    const response = await fetch(`${this.apiEndpoint}/presign`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        filename: file.name,
        mimeType: file.type,
        source: "obsidian"
      })
    });
    if (!response.ok) {
      throw new Error(`Failed to get presigned URL: ${response.status} ${response.statusText}`);
    }
    const data = await response.json();
    if (!data.success) {
      throw new Error(data.error || "Unknown error from API");
    }
    return data;
  }
  /**
   * Upload file to S3 using presigned URL with progress tracking
   */
  async uploadToS3(file, presignedUrl, presignData, onProgress) {
    return new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest();
      xhr.upload.addEventListener("progress", (e) => {
        if (e.lengthComputable) {
          const progress = e.loaded / e.total * 100;
          onProgress(progress);
        }
      });
      xhr.addEventListener("load", () => {
        if (xhr.status === 200) {
          resolve();
        } else {
          reject(new Error(`Upload failed with status: ${xhr.status}`));
        }
      });
      xhr.addEventListener("error", () => {
        reject(new Error("Network error during upload"));
      });
      xhr.addEventListener("abort", () => {
        reject(new Error("Upload cancelled"));
      });
      xhr.open("PUT", presignedUrl);
      xhr.setRequestHeader("Content-Type", presignData.content_type);
      xhr.setRequestHeader("x-amz-meta-source", presignData.metadata.source);
      xhr.setRequestHeader("x-amz-meta-file-hash", presignData.metadata["file-hash"]);
      xhr.setRequestHeader("x-amz-meta-original-filename", presignData.metadata["original-filename"]);
      xhr.send(file);
    });
  }
  /**
   * Notify the backend that upload is complete
   */
  async notifyUploadComplete(presignData) {
    const request = {
      s3Key: presignData.s3_key,
      fileUrl: presignData.file_url,
      originalFilename: presignData.filename,
      source: "obsidian"
    };
    const response = await fetch(`${this.apiEndpoint}/upload-complete`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(request)
    });
    if (!response.ok) {
      throw new Error(`Failed to notify upload complete: ${response.status}`);
    }
    const data = await response.json();
    if (!data.success) {
      throw new Error(data.error || "Upload notification failed");
    }
  }
  /**
   * Wait for WebP conversion to complete
   * Polls the WebP URL until it's available or timeout
   */
  async waitForWebP(webpUrl, maxAttempts = 30, intervalMs = 1e3) {
    for (let i = 0; i < maxAttempts; i++) {
      try {
        const response = await fetch(webpUrl, { method: "HEAD" });
        if (response.ok) {
          return true;
        }
      } catch (error) {
      }
      if (i < maxAttempts - 1) {
        await new Promise((resolve) => setTimeout(resolve, intervalMs));
      }
    }
    return false;
  }
  /**
   * Convert image URL to WebP URL
   */
  convertToWebpUrl(url) {
    return url.replace(/\.(jpg|jpeg|png|gif|bmp)$/i, ".webp");
  }
  /**
   * Complete upload workflow: request URL, upload file, notify completion
   */
  async uploadFile(file, onProgress) {
    onProgress("Requesting upload URL...", 10);
    const presignData = await this.requestPresignedUrl(file);
    onProgress("Uploading to S3...", 20);
    await this.uploadToS3(file, presignData.upload_url, presignData, (uploadProgress) => {
      const overallProgress = 20 + uploadProgress * 0.6;
      onProgress("Uploading to S3...", overallProgress);
    });
    onProgress("Processing...", 80);
    await this.notifyUploadComplete(presignData);
    const isImage = file.type.startsWith("image/");
    if (isImage) {
      onProgress("Converting to WebP...", 85);
      const webpUrl = this.convertToWebpUrl(presignData.file_url);
      const webpReady = await this.waitForWebP(webpUrl, 30, 1e3);
      if (webpReady) {
        presignData.file_url = webpUrl;
      }
    }
    onProgress("Complete", 100);
    return presignData;
  }
};

// src/utils/CodeGenerator.ts
var CodeGenerator = class {
  /**
   * Generate HTML embed code based on file type
   */
  generate(file, s3Url) {
    const isVideo = file.type.startsWith("video/");
    if (isVideo) {
      return this.generateVideoCode(s3Url, file.type);
    } else {
      return this.generateImageCode(s3Url);
    }
  }
  /**
   * Generate HTML code for images
   * Images are converted to WebP format by the backend Lambda
   */
  generateImageCode(s3Url) {
    const webpUrl = this.convertToWebpUrl(s3Url);
    return `<div style='text-align:center;'><img src='${webpUrl}' alt='' style='max-width:100%; height:auto;'></div>`;
  }
  /**
   * Generate HTML code for videos
   */
  generateVideoCode(s3Url, mimeType) {
    return `<video width="800" height="450" controls>
  <source src="${s3Url}" type="${mimeType}">
</video>`;
  }
  /**
   * Convert image URL to WebP format
   * Example: uploads/251230_123456_abc123.jpg -> uploads/251230_123456_abc123.webp
   */
  convertToWebpUrl(url) {
    return url.replace(/\.(jpg|jpeg|png|gif|bmp)$/i, ".webp");
  }
  /**
   * Get file extension from filename
   */
  getFileExtension(filename) {
    const parts = filename.split(".");
    return parts.length > 1 ? parts[parts.length - 1].toLowerCase() : "";
  }
  /**
   * Check if file is an image
   */
  isImage(file) {
    return file.type.startsWith("image/");
  }
  /**
   * Check if file is a video
   */
  isVideo(file) {
    return file.type.startsWith("video/");
  }
};

// src/utils/FileHandler.ts
var FileHandler = class {
  /**
   * Validate if file is supported
   */
  static validateFile(file) {
    const isImage = this.IMAGE_FORMATS.includes(file.type);
    const isVideo = this.VIDEO_FORMATS.includes(file.type);
    if (!isImage && !isVideo) {
      return {
        valid: false,
        error: `Unsupported file type: ${file.type}. Supported formats: JPEG, PNG, GIF, BMP, WebP, MP4, MOV, AVI, MKV, M4V, WebM`
      };
    }
    if (file.size > this.MAX_FILE_SIZE) {
      return {
        valid: false,
        error: `File size exceeds maximum limit of ${this.formatFileSize(this.MAX_FILE_SIZE)}`
      };
    }
    return { valid: true };
  }
  /**
   * Format file size in human-readable format
   */
  static formatFileSize(bytes) {
    if (bytes === 0) return "0 Bytes";
    const k = 1024;
    const sizes = ["Bytes", "KB", "MB", "GB"];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return Math.round(bytes / Math.pow(k, i) * 100) / 100 + " " + sizes[i];
  }
  /**
   * Check if file is an image
   */
  static isImage(file) {
    return this.IMAGE_FORMATS.includes(file.type);
  }
  /**
   * Check if file is a video
   */
  static isVideo(file) {
    return this.VIDEO_FORMATS.includes(file.type);
  }
  /**
   * Get file extension from filename
   */
  static getFileExtension(filename) {
    const parts = filename.split(".");
    return parts.length > 1 ? parts[parts.length - 1].toLowerCase() : "";
  }
  /**
   * Get file name without extension
   */
  static getFileNameWithoutExtension(filename) {
    const parts = filename.split(".");
    if (parts.length > 1) {
      return parts.slice(0, -1).join(".");
    }
    return filename;
  }
  /**
   * Filter valid files from a list
   */
  static filterValidFiles(files) {
    const valid = [];
    const invalid = [];
    files.forEach((file) => {
      const validation = this.validateFile(file);
      if (validation.valid) {
        valid.push(file);
      } else {
        invalid.push({ file, error: validation.error || "Unknown error" });
      }
    });
    return { valid, invalid };
  }
};
// Supported image formats
FileHandler.IMAGE_FORMATS = [
  "image/jpeg",
  "image/png",
  "image/gif",
  "image/bmp",
  "image/webp"
];
// Supported video formats
FileHandler.VIDEO_FORMATS = [
  "video/mp4",
  "video/quicktime",
  // .mov
  "video/x-msvideo",
  // .avi
  "video/x-matroska",
  // .mkv
  "video/x-m4v",
  // .m4v
  "video/webm"
];
// Maximum file size (500MB)
FileHandler.MAX_FILE_SIZE = 500 * 1024 * 1024;

// main.ts
var DEFAULT_SETTINGS = {
  apiEndpoint: "",
  s3Bucket: "",
  awsRegion: "ap-northeast-2",
  enableProgressBar: true,
  autoInsertCode: true
};
var S3UploaderPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addRibbonIcon("upload-cloud", "Upload media to S3", () => {
      new UploadModal(this.app, this).open();
    });
    this.addCommand({
      id: "upload-media-to-s3",
      name: "Upload media to S3",
      callback: () => {
        new UploadModal(this.app, this).open();
      }
    });
    this.addSettingTab(new S3UploaderSettingTab(this.app, this));
    console.log("S3 Media Uploader plugin loaded");
  }
  onunload() {
    console.log("S3 Media Uploader plugin unloaded");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var UploadModal = class extends import_obsidian.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("s3-uploader-modal");
    contentEl.createEl("h2", { text: "Upload Media to S3" });
    const dropzone = contentEl.createDiv({ cls: "s3-dropzone" });
    dropzone.createEl("p", {
      text: "Drag and drop files here",
      cls: "s3-dropzone-text"
    });
    dropzone.createEl("p", {
      text: "or click to browse",
      cls: "s3-dropzone-hint"
    });
    const fileInput = dropzone.createEl("input", {
      type: "file",
      attr: {
        multiple: "true",
        accept: "image/*,video/*"
      }
    });
    dropzone.addEventListener("click", () => {
      fileInput.click();
    });
    dropzone.addEventListener("dragover", (e) => {
      e.preventDefault();
      dropzone.addClass("dragover");
    });
    dropzone.addEventListener("dragleave", () => {
      dropzone.removeClass("dragover");
    });
    dropzone.addEventListener("drop", (e) => {
      var _a;
      e.preventDefault();
      dropzone.removeClass("dragover");
      const files = (_a = e.dataTransfer) == null ? void 0 : _a.files;
      if (files) {
        this.handleFiles(Array.from(files));
      }
    });
    fileInput.addEventListener("change", () => {
      if (fileInput.files) {
        this.handleFiles(Array.from(fileInput.files));
      }
    });
    const fileListContainer = contentEl.createDiv({ cls: "s3-file-list" });
    const progressContainer = contentEl.createDiv({ cls: "s3-progress-container" });
    const progressBar = progressContainer.createDiv({ cls: "s3-progress-bar" });
    const progressFill = progressBar.createDiv({ cls: "s3-progress-fill" });
    progressFill.setText("0%");
    const progressText = progressContainer.createDiv({
      cls: "s3-progress-text",
      text: "Ready to upload"
    });
    const buttonGroup = contentEl.createDiv({ cls: "s3-button-group" });
    const cancelButton = buttonGroup.createEl("button", {
      text: "Cancel",
      cls: "s3-button s3-button-secondary"
    });
    cancelButton.addEventListener("click", () => {
      this.close();
    });
    const uploadButton = buttonGroup.createEl("button", {
      text: "Upload",
      cls: "s3-button s3-button-primary"
    });
    uploadButton.disabled = true;
    uploadButton.addEventListener("click", async () => {
      await this.uploadFiles();
    });
    this.fileListContainer = fileListContainer;
    this.progressContainer = progressContainer;
    this.progressFill = progressFill;
    this.progressText = progressText;
    this.uploadButton = uploadButton;
    this.selectedFiles = [];
  }
  handleFiles(files) {
    const { valid, invalid } = FileHandler.filterValidFiles(files);
    if (invalid.length > 0) {
      invalid.forEach(({ file, error }) => {
        new import_obsidian.Notice(`${file.name}: ${error}`);
      });
    }
    if (valid.length === 0) {
      new import_obsidian.Notice("No valid files selected");
      return;
    }
    this.selectedFiles = valid;
    const fileListContainer = this.fileListContainer;
    fileListContainer.empty();
    valid.forEach((file) => {
      const fileItem = fileListContainer.createDiv({ cls: "s3-file-item" });
      fileItem.createSpan({
        text: file.name,
        cls: "s3-file-name"
      });
      fileItem.createSpan({
        text: this.formatFileSize(file.size),
        cls: "s3-file-size"
      });
    });
    this.uploadButton.disabled = false;
  }
  async uploadFiles() {
    const files = this.selectedFiles;
    if (files.length === 0) {
      new import_obsidian.Notice("No files selected");
      return;
    }
    const progressContainer = this.progressContainer;
    const progressFill = this.progressFill;
    const progressText = this.progressText;
    const uploadButton = this.uploadButton;
    progressContainer.addClass("active");
    uploadButton.disabled = true;
    const uploader = new S3Uploader(this.plugin.settings.apiEndpoint);
    const codeGenerator = new CodeGenerator();
    const uploadedCodes = [];
    try {
      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        const presignData = await uploader.uploadFile(file, (stage, progress) => {
          const fileStartProgress = i / files.length * 100;
          const fileEndProgress = (i + 1) / files.length * 100;
          const fileProgress = fileStartProgress + progress / 100 * (fileEndProgress - fileStartProgress);
          progressFill.style.width = `${fileProgress}%`;
          progressFill.setText(`${Math.round(fileProgress)}%`);
          progressText.setText(`${stage} - ${file.name} (${i + 1}/${files.length})`);
        });
        const htmlCode = codeGenerator.generate(file, presignData.file_url);
        uploadedCodes.push(htmlCode);
        console.log(`Uploaded: ${file.name} -> ${presignData.file_url}`);
      }
      progressText.setText("Upload completed!");
      progressFill.style.width = "100%";
      progressFill.setText("100%");
      if (this.plugin.settings.autoInsertCode && uploadedCodes.length > 0) {
        this.insertCodesToEditor(uploadedCodes);
      }
      new import_obsidian.Notice(`Successfully uploaded ${files.length} file(s)!`);
      setTimeout(() => this.close(), 1500);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      new import_obsidian.Notice(`Upload failed: ${errorMessage}`);
      console.error("Upload error:", error);
      uploadButton.disabled = false;
      progressContainer.removeClass("active");
    }
  }
  /**
   * Insert HTML codes to the active editor
   */
  insertCodesToEditor(codes) {
    var _a;
    const editor = (_a = this.app.workspace.activeEditor) == null ? void 0 : _a.editor;
    if (!editor) {
      new import_obsidian.Notice("No active editor found");
      return;
    }
    console.log(`Inserting ${codes.length} codes to editor`);
    console.log(`Codes array:`, codes);
    const cursor = editor.getCursor();
    const codeBlock = codes.join("\n\n");
    console.log(`Joined codeBlock length: ${codeBlock.length} characters`);
    console.log(`CodeBlock preview:`, codeBlock.substring(0, 200));
    editor.replaceRange(codeBlock + "\n\n", cursor);
    new import_obsidian.Notice(`HTML code inserted to editor (${codes.length} files)`);
  }
  formatFileSize(bytes) {
    if (bytes === 0) return "0 Bytes";
    const k = 1024;
    const sizes = ["Bytes", "KB", "MB", "GB"];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return Math.round(bytes / Math.pow(k, i) * 100) / 100 + " " + sizes[i];
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var S3UploaderSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "S3 Media Uploader Settings" });
    new import_obsidian.Setting(containerEl).setName("API Endpoint").setDesc("AWS API Gateway endpoint URL").addText((text) => text.setPlaceholder("https://...").setValue(this.plugin.settings.apiEndpoint).onChange(async (value) => {
      this.plugin.settings.apiEndpoint = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("S3 Bucket").setDesc("AWS S3 bucket name").addText((text) => text.setPlaceholder("my-bucket").setValue(this.plugin.settings.s3Bucket).onChange(async (value) => {
      this.plugin.settings.s3Bucket = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("AWS Region").setDesc("AWS region (e.g., ap-northeast-2)").addText((text) => text.setPlaceholder("ap-northeast-2").setValue(this.plugin.settings.awsRegion).onChange(async (value) => {
      this.plugin.settings.awsRegion = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Enable Progress Bar").setDesc("Show upload progress").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableProgressBar).onChange(async (value) => {
      this.plugin.settings.enableProgressBar = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Auto Insert Code").setDesc("Automatically insert HTML embed code after upload").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoInsertCode).onChange(async (value) => {
      this.plugin.settings.autoInsertCode = value;
      await this.plugin.saveSettings();
    }));
  }
};
